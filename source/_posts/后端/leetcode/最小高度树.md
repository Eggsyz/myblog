---
title: 最小高度树
date:  2020-04-14T20:20:03
categories: leetcode
tags:
- 每日一题
- 树 
- 递归
---

给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。

**示例:**

```
给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

          0 
         / \ 
       -3   9 
       /   / 
     -10  5 

```

## 题目详解

首先，认真解题，该题目标是将一个**有序**数组转换成一个**高度最小**的二叉搜索树。从这句话可以得出两条信息：

1. 高度最小的二叉搜索树
2. 输入的是有序数组

那么怎样的二叉搜索树才是一个高度最低的树呢？

也许很多人第一反应无法想出这个树的类型，但是大家肯定知道如果树的每个节点的叶子节点尽量都是满的（即左右节叶子节点高度均匀），那么这个树的高度肯定最小。到此，大家可能就知道了AVL树（二叉平衡树）。

接下来解决第二个问题，有序数组转换为AVL树。结合上面的分析，很容易想到取中间节点为根节点，左侧为左子树，右侧为右子树，按照这个规则，生成的二叉搜索树高度肯定最低。本文通过递归来实现代码。

## 代码

```go
func sortedArrayToBST(nums []int) *TreeNode {
	var length = len(nums)
	if length == 0 {
		return nil
	}
  var root = new(TreeNode)
	var mid = length / 2
	root.Val = nums[mid]
	if 0 < mid {
		root.Left = sortedArrayToBST(nums[0:mid])
	}
	if mid+1 < len(nums) {
		root.Right = sortedArrayToBST(nums[mid+1 : len(nums)])
	}
	return root
}
```



