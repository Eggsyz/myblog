---
title: n个骰子的点数
date:  2020-04-18T21:20:03
categories: leetcode
tags:
- 每日一题
- 树
- 递归
---

把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。

 

你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。

 

示例 1:

    输入: 1
    输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]

示例 2:

    输入: 2
    输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]

限制：

1 <= n <= 11

## 题目详解

本题可以采用动态规划算法解决：首先，在本题中，投掷 n个骰子，所有点数出现的总次数是 6^n ，因为一共有 n枚骰子，每枚骰子的点数都有 6 种可能出现的情况。并且第n个骰子摇出来的骰子数量与第n-1个骰子摇出来的数量相关。即因此投掷完 n 枚骰子后点数 jj出现的次数，可以由投掷完 n-1枚骰子后，对应点数j-1，j−2，j−3，...，j−6 出现的次数之和转化过来。

```
dp[n][j]= ∑ dp[n−1][j−i] 1<=i<=6
```



## 代码

```go
/*
 *  第n个骰子摇出j点的次数是在第n-1个骰子摇出j-1,j-2,j-3,j-4,j-5,j-6这几种情况之和。
 *
 */
func twoSum(n int) []float64 {
	var nums = make([][]int, n+1)
	for i := 0; i <= n; i++ {
		nums[i] = make([]int, 6*n+1)
	}
	for i := 1; i <= 6; i++ {
		nums[1][i] = 1
	}
	for i := 2; i <= n; i++ { // 第几个骰子
		for j := i; j <= 6*i; j++ { // 能摇出的值
			for k := 1; k <= 6; k++ { 
				if j-k <= 0 {
					break
				}
				nums[i][j] += nums[i-1][j-k]
			}
		}
	}
	sum := math.Pow(6, float64(n))
	var res = make([]float64, 5*n+1) // 保存值的结果为n到6*n，一共5*n+1个
	for i := n; i <= 6*n; i++ {
		res[i-n] = float64(nums[n][i]) / sum
	}
	return res
}
```

## 复杂度分析

+ 时间复杂度：`O(N*N)`
+ 空间复杂度：`O(N)`

