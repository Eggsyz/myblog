---
title: 二叉树的遍历
date:  2020-03-31T20:20:03
categories: leetcode
tags:
- 每日一题
- 动态规划 
---

本文介绍二叉树的几种遍历模式。

# 二叉树的遍历

有两种通用的遍历树的策略：

+ 深度优先搜索（DFS）

在这个策略中，我们采用深度作为优先级，以便从跟开始一直到达某个确定的叶子，然后再返回根到达另一个分支。

深度优先搜索策略又可以根据根节点、左孩子和右孩子的相对顺序被细分为前序遍历，中序遍历和后序遍历。

+ 宽度优先搜索（BFS）

我们按照高度顺序一层一层的访问整棵树，高层次的节点将会比低层次的节点先被访问到。

## 二叉树的前序遍历

给定一个二叉树，返回它的 前序 遍历。

 示例:

```
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [1,2,3]
```

进阶: 递归算法很简单，你可以通过迭代算法完成吗？

### 题目详解

本题可以采用深度优先搜索（DFS）。

+ 递归求解比较简单，首先添加当前节点，然后遍历左子树，再遍历右子树。其他遍历方式类似。

+ 迭代解法，需要定义一个栈，保存还需要遍历的节点。

  1. 先删除当前节点
  2. 然后添加右叶子节点
  3. 再添加左叶子节点

  则下一次遍历时优先遍历左叶子节点，如果存在子节点，按照上述逻辑添加入栈。按照这个逻辑保存当前节点值，最后顺序输出即可。

### 代码

+ 递归解法

```go
func preorderTraversal(root *TreeNode) []int {
    var res []int
    if root==nil{
        return res 
    }
    dfs(root,&res)
    return res 
}
func dfs(root *TreeNode, res *[]int){
    if root==nil{
        return
    }
    *res=append(*res,root.Val)
    dfs(root.Left,res)
    dfs(root.Right,res)
}
```

+ 迭代解法

```go
func preorderTraversal(root *TreeNode) []int {
    var res []int
    if root==nil{
        return res 
    }
    var nodes []*TreeNode
    nodes=append(nodes,root)
    for len(nodes)!=0{
        node:=nodes[len(nodes)-1]
        res=append(res,node.Val)
        nodes=nodes[0:len(nodes)-1]
        if node.Right!=nil{
            nodes=append(nodes,node.Right)
        }
        if node.Left!=nil{
            nodes=append(nodes,node.Left)
        }
    }
    return res
}
```

## 二叉树的后序遍历

给定一个二叉树，返回它的 后序 遍历。

 示例:

```
输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]
```

进阶: 递归算法很简单，你可以通过迭代算法完成吗？

### 题目详解

本题可以采用深度优先搜索（DFS）。

+ 递归求解比较简单，首先遍历左子树，再遍历右子树。最后添加当前节点。其他遍历方式类似。

+ 迭代解法，需要定义一个栈，保存还需要遍历的节点。

  1. 先删除当前节点
  2. 然后添加左叶子节点
  3. 再添加右叶子节点

  则下一次遍历时优先遍历右叶子节点，如果存在子节点，按照上述逻辑添加入栈。按照这个逻辑保存当前节点值，最后将结果逆序输出即可。

### 代码

+ 递归解法

```go
func postorderTraversal(root *TreeNode) []int {
    var res []int
    if root==nil{
        return res
    }
    dfs(root,&res)
    return res
}

func dfs(root *TreeNode,res *[]int){
    if root==nil{
        return
    }
    dfs(root.Left,res)
    dfs(root.Right,res)
    *res=append(*res,root.Val)
}
```

+ 迭代解法

```go
func postorderTraversal(root *TreeNode) []int {
    var res []int
    if root==nil{
        return res
    }
    var nodes []*TreeNode
    nodes=append(nodes,root)
    // 此时，我们保存根节点的值，然后保存右子树遍历结果，再保存左子树遍历结果，最后逆序输出即可
    for len(nodes)!=0{
        node:=nodes[len(nodes)-1]
        res=append(res,node.Val)
        nodes=nodes[:len(nodes)-1]
        if node.Left!=nil{
            nodes=append(nodes,node.Left)
        }
        if node.Right!=nil{
            nodes=append(nodes,node.Right)
        }
    }
    reverse(res)
    return res
}
func reverse(tmp []int){
    length := len(tmp)
    for i := 0; i < length/2; i++{
        tmp[i], tmp[length - i - 1] = tmp[length - i - 1], tmp[i]
    }
}
```

## 二叉树的中序遍历

给定一个二叉树，返回它的中序 遍历。

示例:

```
输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]进阶: 递归算法很简单，你可以通过迭代算法完成吗？
```

### 题目详解

本题可以采用深度优先搜索（DFS）。

+ 递归求解比较简单，首先遍历左子树，再添加当前节点，最后遍历右子树。

+ 迭代解法，需要定义一个栈，保存还需要遍历的节点。

  1. 先删除当前节点
  2. 然后添加左叶子节点
  3. 再添加右叶子节点

  则下一次遍历时优先遍历右叶子节点，如果存在子节点，按照上述逻辑添加入栈。按照这个逻辑保存当前节点值，最后将结果逆序输出即可。

### 代码

+ 递归解法

```go
func inorderTraversal(root *TreeNode) []int {
    var res []int
    if root==nil{
        return res
    }
    dfs(root,&res)
    return res
}

func dfs(root *TreeNode, res *[]int){
    if root==nil{
        return
    }
    dfs(root.Left,res)
    *res=append(*res,root.Val)
    dfs(root.Right,res)
}
```

+ 迭代解法

```go

```

