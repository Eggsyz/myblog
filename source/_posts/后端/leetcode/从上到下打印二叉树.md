---
title: 从上到下打印二叉树
date:  2020-05-08T20:20:03
categories: leetcode
tags:
- 每日一题
- 树
---



## 从上到下打印二叉树

### 从上到下打印二叉树

从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。 

例如:

给定二叉树: [3,9,20,null,null,15,7],

```
    3
   / \
  9  20
    /  \
   15   7
```

返回：

```
[3,9,20,15,7]
```

提示：

1. `节点总数 <= 1000`

#### 题目详解

本题可以定义一个node切片，按照每层顺序保存节点，然后从保存第一个节点的值，并在node切片中添加 该节点的左右子节点。这样就可以实现层层遍历。

####  代码

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

func levelOrder(root *TreeNode) []int {
	var res []int
	if root == nil {
		return res
	}
	var queue []*TreeNode
	queue = append(queue, root)
	for len(queue) != 0 {
		res = append(res, queue[0].Val)
		if queue[0].Left != nil {
			queue = append(queue, queue[0].Left)
		}
		if queue[0].Right != nil {
			queue = append(queue, queue[0].Right)
		}
		queue = queue[1:]
	}
	return res
}
```

#### 复杂度分析

+ 时间复杂度 O(N)：所有节点都需要遍历
+ 空间复杂度 O(N):  最差情况下会保存N/2个节点（保存的节点只会是一层节点），满二叉树的情况。



### 从上到下打印二叉树 II

从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

例如:
给定二叉树: `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回其层次遍历结果：

```
[
  [3],
  [9,20],
  [15,7]
]
```

提示：

1. `节点总数 <= 1000`

#### 题目详解

本题可以定义2个node切片，其中nodeA保存一层节点，nodeB保存nodeA的下一层节点，互相交替遍历，统计每层结果。

#### 代码

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func levelOrder(root *TreeNode) [][]int {
	var res [][]int
	if root == nil {
		return res
	}
	var nodesA []*TreeNode
	var nodesB []*TreeNode
	nodesA = append(nodesA, root)
	for len(nodesA) != 0 || len(nodesB) != 0 {
		var tmp []int
		//遍历A这一层的子节点以及保存A层节点值
		for i := 0; i < len(nodesA); i++ {
			tmp = append(tmp, nodesA[i].Val)
			if nodesA[i].Left != nil {
				nodesB = append(nodesB, nodesA[i].Left)
			}
			if nodesA[i].Right != nil {
				nodesB = append(nodesB, nodesA[i].Right)
			}
		}
		// 此时A层遍历结束
		if len(tmp) != 0 {
			nodesA = nil
			res = append(res, tmp)
			tmp = nil
		}
		//遍历B这一层的子节点以及保存B层节点值
		for i := 0; i < len(nodesB); i++ {
			tmp = append(tmp, nodesB[i].Val)
			if nodesB[i].Left != nil {
				nodesA = append(nodesA, nodesB[i].Left)
			}
			if nodesB[i].Right != nil {
				nodesA = append(nodesA, nodesB[i].Right)
			}
		}
		// 此时B层遍历结束
		if len(tmp) != 0 {
			nodesB = nil
			res = append(res, tmp)
		}
	}
	return res
}
```

#### 复杂度分析

+ 时间复杂度 O(N)：所有节点都需要遍历
+ 空间复杂度 O(N):  最差情况下会保存N/2个节点（保存的节点只会是一层节点），满二叉树的情况。



### 从上到下打印二叉树 III

请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

 例如:
给定二叉树: `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回其层次遍历结果：

```
[
  [3],
  [20,9],
  [15,7]
]
```

提示：

1. `节点总数 <= 1000`

#### 题目详解

本题可以定义2个node切片，其中nodeA保存一层节点，nodeB保存nodeA的下一层节点，互相交替遍历，统计每层结果，只是在第二层时，需要逆序保存节点的val。

#### 代码

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func levelOrder(root *TreeNode) [][]int {
    var res [][]int
	if root == nil {
		return res
	}
	var nodesA []*TreeNode
	var nodesB []*TreeNode
	nodesA = append(nodesA, root)
	for len(nodesA) != 0 || len(nodesB) != 0 {
		var tmp []int
		//遍历A这一层的子节点以及保存A层节点值，此时需要顺序保存val
		for i := 0; i < len(nodesA); i++ {
			tmp = append(tmp, nodesA[i].Val)
			if nodesA[i].Left != nil {
				nodesB = append(nodesB, nodesA[i].Left)
			}
			if nodesA[i].Right != nil {
				nodesB = append(nodesB, nodesA[i].Right)
			}
		}
		// 此时A层遍历结束
		if len(tmp) != 0 {
			nodesA = nil
			res = append(res, tmp)
			tmp = nil
		}
		//遍历B这一层的子节点以及保存B层节点值，此时需要逆序保存val
		for i := 0; i < len(nodesB); i++ {
			tmp = append([]int{nodesB[i].Val}, tmp...)
			if nodesB[i].Left != nil {
				nodesA = append(nodesA, nodesB[i].Left)
			}
			if nodesB[i].Right != nil {
				nodesA = append(nodesA, nodesB[i].Right)
			}
		}
		// 此时B层遍历结束
		if len(tmp) != 0 {
			nodesB = nil
			res = append(res, tmp)
		}
	}
	return res
}
```

#### 复杂度分析

+ 时间复杂度 O(N)：所有节点都需要遍历
+ 空间复杂度 O(N):  最差情况下会保存N/2个节点（保存的节点只会是一层节点），满二叉树的情况。

