---
title: 重建二叉树
date:  2020-05-05T16:20:03
categories: leetcode
tags:
- 每日一题
- 树 
---

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

例如，给出

```
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
```

返回如下的二叉树：

```
    3
   / \
  9  20
    /  \
   15   7
```

限制：

0 <= 节点个数 <= 5000

## 题目详解

首先，认真解题，题目强调的是基于前序遍历和中序遍历恢复二叉树。首先了解一下前序遍历和中序遍历。

```
    3
   / \
  9  20
    /  \
   15   7
```

以样例为例，**前序遍历**，其遍历过程为先遍历根节点，再遍历左子树，最后遍历右子树，因此该树前序遍历结果为

```
3->9->20->15->7
```

**中序遍历**，其遍历过程为先遍历左子树，再遍历根节点，最后遍历右子树。则样例树的中序遍历结果为：

```
9->3->15->20->7
```

顺便介绍一下**后序遍历**，其遍历过程为先遍历左子树，再遍历右子树，最后遍历根节点，则样例的后序遍历结果为

```
9->15->7->20->3
```

现在，回归本题，如何基于前序遍历和中序遍历恢复二叉树呢？通过研究发现，前序遍历第一个就是根节点，后面只需要在中序遍历找到该节点的位置index，那么在中序遍历数组中index之前的值肯定是左子树节点中序遍历结果，index之后的为右子树节点中序遍历数组，那么在前序遍历数组中1:1+index为左子树节点前序遍历，在index+1:last为右子树前序遍历结果。

## 代码

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

 // 前序遍历代表中左右，中序遍历代表左中右。因此可以基于中来将左右子树分开，然后递归重构左右子树即可即可
func buildTree(preorder []int, inorder []int) *TreeNode {
    if len(preorder)==0||len(inorder)==0{
        return nil
    }
    // 第一步，构建root节点
    var root =new(TreeNode)
    root.Val=preorder[0]
    // 第二步，找到左子树数组
    var index int // 代表中序遍历左子树数组最右侧索引，也代表左子树节点数量
    for i:=0;i<len(inorder);i++{
        if inorder[i]==root.Val{
            index=i
            break
        }
    }
    // 递归计算其左子树和右子树
    root.Left=buildTree(preorder[1:index+1],inorder[:index])
    root.Right=buildTree(preorder[index+1:],inorder[index+1:])
    return root
}
```



