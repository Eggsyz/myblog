---
title: 树的子结构
date:  2020-05-07T20:20:03
categories: leetcode
tags:
- 每日一题
- 树
---

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

例如:
给定的树 A:

         3
        / \
       4   5
      / \
     1   2

给定的树 B：

```
   4 
  /
 1
```

返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。

示例 1：

```
输入：A = [1,2,3], B = [3,1]
输出：false
```

示例 2：

```
输入：A = [3,4,5,1,2], B = [4,1]
输出：true
```


限制：

0 <= 节点个数 <= 10000

## 题目详解

看到上题，经过思考可以采用递归进行求解，B是不是A的子树可以分为以下3种情况：

1. B是以A为根节点的子树，即B的根节点和A的根节点相同
2. B是以A的左子树的子树，即B在A的左子树上
3. B是以A的右子树的子树，即B在A的右子树上

## 代码

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func isSubStructure(A *TreeNode, B *TreeNode) bool {
    if A==nil||B==nil{
        return false
    }
  	// B是A的子树/B是A的左子树的子树/B是A的右子树的子树
    return SubStructure(A,B)||isSubStructure(A.Left,B)||isSubStructure(A.Right,B)
}

// 判断两个B是否是A的子树结构
func SubStructure(A *TreeNode, B *TreeNode) bool {
    if A==nil&&B==nil{
        return true
    }
    if A==nil{
        return false
    }
    if B==nil{
        return true
    }
    if A.Val!=B.Val{
        return false
    }
    return SubStructure(A.Left,B.Left)&&SubStructure(A.Right,B.Right)
}
```

## 算法复杂度

+ 空间复杂度O(H)，H为树的高度
+ 时间复杂度为O(MN)，其中M、N为A、B这两颗树的节点数

